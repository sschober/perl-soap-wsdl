[% USE XSD(context) %]
package [% XSD.create_xsd_name(attribute) %];
use strict;
use warnings;

{ # BLOCK to scope variables

sub get_xmlns { '[% attribute.get_targetNamespace %]' }

__PACKAGE__->__set_name('[% attribute.get_name %]');
__PACKAGE__->__set_ref([% IF attribute.get_ref; %]'[% attribute.get_ref %]'[% END %]);

[%- IF (type_name = attribute.get_type); -%]
use base qw(
    SOAP::WSDL::XSD::Typelib::Attribute
    [% type = definitions.get_types.0.find_type(attribute.expand(type_name));
    IF ! type;
        THROW NOT_FOUND "type " _ type_name _ " not found in attribute " _ attribute.get_name;
    END;
    XSD.create_xsd_name(type) %]
);

}
[%- ELSIF (ref = attribute.get_ref);
    ref_from = ref.split(':');
-%]
# attribute ref="[% ref %]"
use base qw(
    [% ref_element = definitions.get_types.0.find_attribute(attribute.expand(ref));
    XSD.create_xsd_name( ref_element ); %]
);

}
[%- ELSIF (simpleType = attribute.first_simpleType) %]
# atomic simpleType: <attribute><simpleType
use base qw(
    SOAP::WSDL::XSD::Typelib::Attribute
);
[% INCLUDE simpleType/contentModel.tt -%]

}

[% END %]

1;

[%# work around for CPAN's indexer, which gets disturbed by pod in templates -%]
[% pod = BLOCK %]=pod[% END -%]
[% head1 = BLOCK %]=head1[% END -%]
[% head2 = BLOCK %]=head2[% END -%]
[% head3 = BLOCK %]=head3[% END -%]

[% pod %]

[% head1 %] NAME

[% XSD.create_xsd_name(attribute) %]

[% head1 %] DESCRIPTION

Perl data type class for the XML Schema defined attribute
[% attribute.get_name %] from the namespace [% attribute.get_targetNamespace %].

[% INCLUDE POD/annotation.tt(node = attribute) %]

[% INCLUDE element/POD/contentModel.tt(element = attribute) %]

[% head1 %] METHODS

[% head2 %] new

 my $element = [% XSD.create_xsd_name(attribute) %]->new($data);

Constructor. The following data structure may be passed to new():

 { value => $value }

[% head1 %] AUTHOR

Generated by SOAP::WSDL

=cut

