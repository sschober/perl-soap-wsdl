[% USE XSD(context) %]
package [% XSD.create_xsd_name(element) %];
use strict;
use warnings;

{ # BLOCK to scope variables

sub get_xmlns { '[% element.get_targetNamespace %]' }

__PACKAGE__->__set_name('[% element.get_name %]');
__PACKAGE__->__set_nillable([% IF (element.get_nillable);
        IF (element.get_nillable != 'false'); %]1[% ELSE %]0[% END;
    END;
 %]);
__PACKAGE__->__set_minOccurs([% element.get_minOccurs %]);
__PACKAGE__->__set_maxOccurs([% element.get_maxOccurs %]);
__PACKAGE__->__set_ref([% IF element.get_ref; %]'[% element.get_ref %]'[% END %]);

[%- IF (type_name = element.get_type); -%]
use base qw(
    SOAP::WSDL::XSD::Typelib::Element
    [% type = definitions.get_types.0.find_type(element.expand(type_name));
    XSD.create_xsd_name(type) %]
);

}
[%- ELSIF (ref = element.get_ref);
    ref_from = ref.split(':');
-%]
# element ref="[% ref %]"
use base qw(
    [% ref_element = definitions.get_types.0.find_element(element.expand(ref));
    XSD.create_xsd_name( ref_element ); %]
);

}
[%- ELSIF (simpleType = element.first_simpleType) %]
# atomic simpleType: <element><simpleType
use base qw(
    SOAP::WSDL::XSD::Typelib::Element
);
[% INCLUDE simpleType/contentModel.tt -%]

}

[% ELSIF (complexType = element.first_complexType) %]
use base qw(
    SOAP::WSDL::XSD::Typelib::Element
    SOAP::WSDL::XSD::Typelib::ComplexType
);

[% INCLUDE complexType/contentModel.tt -%]

} # end of BLOCK

[% END %]

1;

[%# work around for CPAN's indexer, which gets disturbed by pod in templates -%]
[% pod = BLOCK %]=pod[% END -%]
[% head1 = BLOCK %]=head1[% END -%]
[% head2 = BLOCK %]=head2[% END -%]
[% head3 = BLOCK %]=head3[% END -%]

[% pod %]

[% head1 %] NAME

[% XSD.create_xsd_name(element) %]

[% head1 %] DESCRIPTION

Perl data type class for the XML Schema defined element
[% element.get_name %] from the namespace [% element.get_targetNamespace %].

[% INCLUDE POD/annotation.tt(node = element) %]

[% IF (complexType = element.first_complexType);
    IF (complexType.get_element); %]

[% head1 %] PROPERTIES

The following properties may be accessed using get_PROPERTY / set_PROPERTY
methods:

=over

[%      FOREACH child_element = complexType.get_element -%]
=item * [% XSD.perl_var_name(XSD.element_name(child_element)) %]

 $element->set_[% XSD.perl_var_name(XSD.element_name(child_element)) %]($data);
 $element->get_[% XSD.perl_var_name(XSD.element_name(child_element)) %]();

[%          IF (XSD.perl_var_name(XSD.element_name(child_element)) == child_element.get_name); %]
[%          ELSE %]
Note: The name of this property has been altered, because it didn't match
perl's notion of variable/subroutine names. The altered name is used in
perl code only, XML output uses the original name:

 [% child_element.get_name %]

[%          END %]

[%      END; %]
=back
[%    END;
END; -%]


[% head1 %] METHODS

[% head2 %] new

 my $element = [% XSD.create_xsd_name(element) %]->new($data);

Constructor. The following data structure may be passed to new():

[% indent = ' '; INCLUDE element/POD/structure.tt; %]

[% head1 %] AUTHOR

Generated by SOAP::WSDL

=cut

